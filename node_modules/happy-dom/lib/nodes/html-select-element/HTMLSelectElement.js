"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const HTMLElement_1 = __importDefault(require("../html-element/HTMLElement"));
const ValidityState_1 = __importDefault(require("../validity-state/ValidityState"));
const HTMLOptionElement_1 = __importDefault(require("../html-option-element/HTMLOptionElement"));
const HTMLOptionsCollection_1 = __importDefault(require("../html-option-element/HTMLOptionsCollection"));
const NodeTypeEnum_1 = __importDefault(require("../node/NodeTypeEnum"));
/**
 * HTML Select Element.
 *
 * Reference:
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLSelectElement.
 */
class HTMLSelectElement extends HTMLElement_1.default {
    constructor() {
        super(...arguments);
        this.options = new HTMLOptionsCollection_1.default(this);
        // Events
        this.onchange = null;
        this.oninput = null;
    }
    /**
     * Returns name.
     *
     * @returns Name.
     */
    get name() {
        return this.getAttributeNS(null, 'name') || '';
    }
    /**
     * Sets name.
     *
     * @param name Name.
     */
    set name(name) {
        this.setAttributeNS(null, 'name', name);
    }
    /**
     * Returns disabled.
     *
     * @returns Disabled.
     */
    get disabled() {
        return this.getAttributeNS(null, 'disabled') !== null;
    }
    /**
     * Sets disabled.
     *
     * @param disabled Disabled.
     */
    set disabled(disabled) {
        if (!disabled) {
            this.removeAttributeNS(null, 'disabled');
        }
        else {
            this.setAttributeNS(null, 'disabled', '');
        }
    }
    /**
     * Returns multiple.
     *
     * @returns Multiple.
     */
    get multiple() {
        return this.getAttributeNS(null, 'multiple') !== null;
    }
    /**
     * Sets multiple.
     *
     * @param multiple Multiple.
     */
    set multiple(multiple) {
        if (!multiple) {
            this.removeAttributeNS(null, 'multiple');
        }
        else {
            this.setAttributeNS(null, 'multiple', '');
        }
    }
    /**
     * Returns autofocus.
     *
     * @returns Autofocus.
     */
    get autofocus() {
        return this.getAttributeNS(null, 'autofocus') !== null;
    }
    /**
     * Sets autofocus.
     *
     * @param autofocus Autofocus.
     */
    set autofocus(autofocus) {
        if (!autofocus) {
            this.removeAttributeNS(null, 'autofocus');
        }
        else {
            this.setAttributeNS(null, 'autofocus', '');
        }
    }
    /**
     * Returns length.
     *
     * @returns length.
     */
    get length() {
        return this.options.length;
    }
    /**
     * Sets length.
     *
     * @param length Length.
     */
    set length(length) {
        this.options.length = length;
    }
    /**
     * Returns required.
     *
     * @returns Required.
     */
    get required() {
        return this.getAttributeNS(null, 'required') !== null;
    }
    /**
     * Sets required.
     *
     * @param required Required.
     */
    set required(required) {
        if (!required) {
            this.removeAttributeNS(null, 'required');
        }
        else {
            this.setAttributeNS(null, 'required', '');
        }
    }
    /**
     * Returns type.
     *
     * @returns type.
     */
    get type() {
        return this.hasAttributeNS(null, 'multiple') ? 'select-multiple' : 'select-one';
    }
    /**
     * Returns value.
     *
     * @returns Value.
     */
    get value() {
        if (this.options.selectedIndex === -1) {
            return '';
        }
        const option = this.options[this.options.selectedIndex];
        return option instanceof HTMLOptionElement_1.default ? option.value : '';
    }
    /**
     * Sets value.
     *
     * @param value Value.
     */
    set value(value) {
        this.options.selectedIndex = this.options.findIndex((o) => o instanceof HTMLOptionElement_1.default && o.value === value);
    }
    /**
     * Returns value.
     *
     * @returns Value.
     */
    get selectedIndex() {
        return this.options.selectedIndex;
    }
    /**
     * Sets value.
     *
     * @param value Value.
     */
    set selectedIndex(value) {
        this.options.selectedIndex = value;
    }
    /**
     * Returns the parent form element.
     *
     * @returns Form.
     */
    get form() {
        let parent = this.parentNode;
        while (parent && parent.tagName !== 'FORM') {
            parent = parent.parentNode;
        }
        return parent;
    }
    /**
     * Returns validity state.
     *
     * @returns Validity state.
     */
    get validity() {
        return new ValidityState_1.default(this);
    }
    /**
     * Returns "true" if it will validate.
     *
     * @returns "true" if it will validate.
     */
    get willValidate() {
        return (this.type !== 'hidden' &&
            this.type !== 'reset' &&
            this.type !== 'button' &&
            !this.disabled &&
            !this['readOnly']);
    }
    /**
     * Returns item from options collection by index.
     *
     * @param index Index.
     */
    item(index) {
        return this.options.item(index);
    }
    /**
     * Adds new option to options collection.
     *
     * @param element HTMLOptionElement or HTMLOptGroupElement to add.
     * @param before HTMLOptionElement or index number.
     */
    add(element, before) {
        this.options.add(element, before);
    }
    /**
     * Removes indexed element from collection or the select element.
     *
     * @param [index] Index.
     */
    remove(index) {
        if (typeof index === 'number') {
            this.options.remove(index);
        }
        else {
            super.remove();
        }
    }
    /**
     * @override
     */
    appendChild(node) {
        if (node.nodeType === NodeTypeEnum_1.default.elementNode) {
            const element = node;
            const previousLength = this.options.length;
            if (element.tagName === 'OPTION' || element.tagName === 'OPTGROUP') {
                this.options.push(element);
                if (this.options.length === 1) {
                    this.options.selectedIndex = 0;
                }
            }
            this._updateIndexProperties(previousLength, this.options.length);
        }
        return super.appendChild(node);
    }
    /**
     * @override
     */
    insertBefore(newNode, referenceNode) {
        const returnValue = super.insertBefore(newNode, referenceNode);
        if (newNode.nodeType === NodeTypeEnum_1.default.elementNode &&
            referenceNode?.nodeType === NodeTypeEnum_1.default.elementNode) {
            const newElement = newNode;
            const previousLength = this.options.length;
            if (newElement.tagName === 'OPTION' || newElement.tagName === 'OPTGROUP') {
                const referenceElement = referenceNode;
                if (referenceElement &&
                    (referenceElement.tagName === 'OPTION' || referenceElement.tagName === 'OPTGROUP')) {
                    const referenceIndex = this.options.indexOf(referenceElement);
                    if (referenceIndex !== -1) {
                        this.options.splice(referenceIndex, 0, newElement);
                    }
                }
                else {
                    this.options.push(newElement);
                }
                if (this.options.length === 1) {
                    this.options.selectedIndex = 0;
                }
            }
            this._updateIndexProperties(previousLength, this.options.length);
        }
        return returnValue;
    }
    /**
     * @override
     */
    removeChild(node) {
        if (node.nodeType === NodeTypeEnum_1.default.elementNode) {
            const element = node;
            const previousLength = this.options.length;
            if (element.tagName === 'OPTION' || element.tagName === 'OPTION') {
                const index = this.options.indexOf(node);
                if (index !== -1) {
                    this.options.splice(index, 1);
                }
                if (this.options.selectedIndex >= this.options.length) {
                    this.options.selectedIndex = this.options.length - 1;
                }
                if (!this.options.length) {
                    this.options.selectedIndex = -1;
                }
            }
            this._updateIndexProperties(previousLength, this.options.length);
        }
        return super.removeChild(node);
    }
    /**
     * Updates index properties.
     *
     * @param previousLength Length before the update.
     * @param newLength Length after the update.
     */
    _updateIndexProperties(previousLength, newLength) {
        if (previousLength > newLength) {
            for (let i = newLength; i < previousLength; i++) {
                if (this.hasOwnProperty(String(i))) {
                    delete this[String(i)];
                }
            }
        }
        else if (previousLength < newLength) {
            for (let i = previousLength; i < newLength; i++) {
                Object.defineProperty(this, String(i), {
                    get: () => {
                        return this.options[i];
                    },
                    enumerable: true,
                    configurable: true
                });
            }
        }
    }
}
exports.default = HTMLSelectElement;
//# sourceMappingURL=HTMLSelectElement.js.map